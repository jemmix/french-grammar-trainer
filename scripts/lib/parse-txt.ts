/**
 * Parser for .txt question files generated by the generate-questions skill.
 *
 * File format:
 *   RULE <rule-id>: <rule title>
 *   Generated by: sonnet
 *   Total: 20 MCQ + 5 input = 25 questions
 *
 *   BEGIN QUESTION
 *   ID: <rule-id>-<NNN>
 *   TYPE: MCQ | INPUT
 *   PROMPT: ...
 *   [PHRASE: ...]        (INPUT only)
 *   RIGHT ANSWER: ...
 *   EXPLANATION: ...
 *   WRONG ANSWER: ...
 *   EXPLANATION: ...
 *   ...
 *   END QUESTION
 */

export interface AnswerPair {
  text: string;
  explanation: string;
}

export interface ParsedMcqQuestion {
  id: string;
  type: "mcq";
  ruleId: string;
  prompt: string;
  right: AnswerPair;
  wrongs: AnswerPair[];
}

export interface ParsedInputQuestion {
  id: string;
  type: "input";
  ruleId: string;
  prompt: string;
  phrase: string;
  right: AnswerPair;
  wrongs: AnswerPair[];
}

export type ParsedQuestion = ParsedMcqQuestion | ParsedInputQuestion;

export interface ParsedFile {
  ruleId: string;
  ruleTitle: string;
  generatedBy: string;
  declaredMcq: number;
  declaredInput: number;
  questions: ParsedQuestion[];
  parseErrors: string[];
}

function deriveRuleId(questionId: string): string {
  // "01-01-001" → "01-01", "10-15-003" → "10-15"
  const parts = questionId.split("-");
  if (parts.length >= 3) return parts.slice(0, 2).join("-");
  return questionId;
}

export function parseTxtFile(content: string): ParsedFile {
  const lines = content.split("\n");

  let ruleId = "";
  let ruleTitle = "";
  let generatedBy = "";
  let declaredMcq = 0;
  let declaredInput = 0;
  const questions: ParsedQuestion[] = [];
  const parseErrors: string[] = [];

  let inQuestion = false;
  let currentId = "";
  let currentType = "";
  let currentPrompt = "";
  let currentPhrase = "";

  interface MutablePair {
    kind: "right" | "wrong";
    text: string;
    explanation: string;
  }
  let currentPairs: MutablePair[] = [];
  let lastPair: MutablePair | null = null;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]!.trim();
    const lineNum = i + 1;

    if (!inQuestion) {
      if (line.startsWith("RULE ")) {
        const m = line.match(/^RULE\s+([^:]+):\s*(.+)$/);
        if (m) {
          ruleId = m[1]!.trim();
          ruleTitle = m[2]!.trim();
        } else {
          parseErrors.push(`Line ${lineNum}: Cannot parse RULE header: "${line}"`);
        }
      } else if (line.startsWith("Generated by:")) {
        generatedBy = line.slice("Generated by:".length).trim();
      } else if (line.startsWith("Total:")) {
        const m = line.match(/(\d+)\s*MCQ\s*\+\s*(\d+)\s*input/i);
        if (m) {
          declaredMcq = parseInt(m[1]!);
          declaredInput = parseInt(m[2]!);
        }
      } else if (line === "BEGIN QUESTION") {
        inQuestion = true;
        currentId = "";
        currentType = "";
        currentPrompt = "";
        currentPhrase = "";
        currentPairs = [];
        lastPair = null;
      }
    } else {
      if (line === "END QUESTION") {
        inQuestion = false;
        const rightPair = currentPairs.find((p) => p.kind === "right");
        const wrongPairs = currentPairs.filter((p) => p.kind === "wrong");
        const qRuleId = currentId ? deriveRuleId(currentId) : ruleId;
        const type = currentType.toUpperCase();

        if (type === "MCQ") {
          questions.push({
            id: currentId,
            type: "mcq",
            ruleId: qRuleId,
            prompt: currentPrompt,
            right: rightPair ? { text: rightPair.text, explanation: rightPair.explanation } : { text: "", explanation: "" },
            wrongs: wrongPairs.map((p) => ({ text: p.text, explanation: p.explanation })),
          });
        } else if (type === "INPUT") {
          questions.push({
            id: currentId,
            type: "input",
            ruleId: qRuleId,
            prompt: currentPrompt,
            phrase: currentPhrase,
            right: rightPair ? { text: rightPair.text, explanation: rightPair.explanation } : { text: "", explanation: "" },
            wrongs: wrongPairs.map((p) => ({ text: p.text, explanation: p.explanation })),
          });
        } else if (currentId || currentType) {
          parseErrors.push(`Line ${lineNum}: Unknown TYPE "${currentType}" for question ID "${currentId}"`);
        }
      } else if (line.startsWith("ID:")) {
        currentId = line.slice(3).trim();
      } else if (line.startsWith("TYPE:")) {
        currentType = line.slice(5).trim();
      } else if (line.startsWith("PROMPT:")) {
        currentPrompt = line.slice(7).trim();
      } else if (line.startsWith("PHRASE:")) {
        currentPhrase = line.slice(7).trim();
      } else if (line.startsWith("RIGHT ANSWER:")) {
        lastPair = { kind: "right", text: line.slice(13).trim(), explanation: "" };
        currentPairs.push(lastPair);
      } else if (line.startsWith("WRONG ANSWER:")) {
        lastPair = { kind: "wrong", text: line.slice(13).trim(), explanation: "" };
        currentPairs.push(lastPair);
      } else if (line.startsWith("EXPLANATION:")) {
        if (lastPair) {
          lastPair.explanation = line.slice(12).trim();
        } else {
          parseErrors.push(`Line ${lineNum}: EXPLANATION without a preceding answer`);
        }
      }
    }
  }

  if (inQuestion) {
    parseErrors.push("File ended without closing END QUESTION");
  }

  return { ruleId, ruleTitle, generatedBy, declaredMcq, declaredInput, questions, parseErrors };
}
