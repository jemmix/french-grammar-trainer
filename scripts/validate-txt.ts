/**
 * Validates .txt question files generated by the generate-questions skill.
 *
 * Checks:
 *   - File header (RULE, Generated by, Total)
 *   - Declared vs actual question counts
 *   - Duplicate question IDs
 *   - MCQ: ≥2 choices, 1 right answer, no duplicate choices, determiner family diversity
 *   - INPUT: exactly 5 wrong answers, PHRASE present and contains ___, no duplicate wrongs
 *
 * Usage: npx tsx scripts/validate-txt.ts <file.txt> [<file2.txt> ...]
 */

import { readFileSync } from "fs";
import { parseTxtFile, type ParsedMcqQuestion, type ParsedInputQuestion } from "./lib/parse-txt.js";

// ============================================================
// Determiner family checking (mirrors validate-content.ts)
// ============================================================

const DETERMINER_FAMILIES: Record<string, string[]> = {
  "défini": ["le", "la", "l'", "les"],
  "indéfini": ["un", "une", "des"],
  "partitif": ["du", "de la", "de l'"],
  "contracté-à": ["au", "aux"],
  "possessif-3s": ["son", "sa", "ses"],
  "possessif-1s": ["mon", "ma", "mes"],
  "possessif-2s": ["ton", "ta", "tes"],
  "possessif-3p": ["leur", "leurs"],
  "possessif-1p": ["notre", "nos"],
  "possessif-2p": ["votre", "vos"],
  "démonstratif": ["ce", "cet", "cette", "ces"],
};

function getFamilies(text: string): string[] {
  const normalized = text.toLowerCase().trim();
  return Object.entries(DETERMINER_FAMILIES)
    .filter(([, members]) => members.includes(normalized))
    .map(([family]) => family);
}

// ============================================================
// Error reporting
// ============================================================

let errorCount = 0;
let warnCount = 0;

function error(id: string, msg: string) {
  console.error(`  ERROR [${id}]: ${msg}`);
  errorCount++;
}

function warn(id: string, msg: string) {
  console.warn(`  WARN  [${id}]: ${msg}`);
  warnCount++;
}

// ============================================================
// Question validators
// ============================================================

function validateMcq(q: ParsedMcqQuestion) {
  if (!q.id) { error("?", "MCQ question has no ID"); return; }
  if (!q.prompt.trim()) error(q.id, "Empty PROMPT");
  if (!q.right.text.trim()) error(q.id, "Missing RIGHT ANSWER");
  if (!q.right.explanation.trim()) warn(q.id, "Empty explanation for right answer");

  const totalChoices = 1 + q.wrongs.length;
  if (totalChoices < 2) error(q.id, `Only ${totalChoices} choice(s) — need at least 2`);

  for (const w of q.wrongs) {
    if (!w.text.trim()) error(q.id, "Empty WRONG ANSWER text");
    if (!w.explanation.trim()) warn(q.id, `Empty explanation for wrong answer "${w.text}"`);
  }

  // Duplicate choices (case-insensitive)
  const allTexts = [q.right.text, ...q.wrongs.map((w) => w.text)];
  const seen = new Map<string, number>();
  for (let i = 0; i < allTexts.length; i++) {
    const key = allTexts[i]!.toLowerCase().trim();
    if (seen.has(key)) {
      error(q.id, `Duplicate choice "${allTexts[i]}" (indices ${seen.get(key)} and ${i})`);
    }
    seen.set(key, i);
  }

  // Determiner family diversity: max 2 from same family
  const familyCounts = new Map<string, string[]>();
  for (const text of allTexts) {
    for (const family of getFamilies(text)) {
      const existing = familyCounts.get(family) ?? [];
      existing.push(text);
      familyCounts.set(family, existing);
    }
  }
  for (const [family, members] of familyCounts) {
    if (members.length > 2) {
      error(q.id, `${members.length} choices from family "${family}": ${members.join(", ")} — max 2 allowed`);
    }
  }
}

function validateInput(q: ParsedInputQuestion) {
  if (!q.id) { error("?", "INPUT question has no ID"); return; }
  if (!q.prompt.trim()) error(q.id, "Empty PROMPT");
  if (!q.phrase.trim()) error(q.id, "Empty PHRASE");
  else if (!q.phrase.includes("___")) warn(q.id, "PHRASE does not contain ___ blank");

  if (!q.right.text.trim()) error(q.id, "Missing RIGHT ANSWER");
  if (!q.right.explanation.trim()) warn(q.id, "Empty explanation for right answer");

  if (q.wrongs.length < 4) {
    error(q.id, `INPUT question must have at least 4 wrong answers, found ${q.wrongs.length}`);
  }

  const seen = new Map<string, number>();
  for (let i = 0; i < q.wrongs.length; i++) {
    const w = q.wrongs[i]!;
    if (!w.text.trim()) error(q.id, `Empty wrong answer text at index ${i}`);
    if (!w.explanation.trim()) warn(q.id, `Empty explanation for wrong answer "${w.text}"`);

    const key = w.text.toLowerCase().trim();
    if (seen.has(key)) {
      error(q.id, `Duplicate wrong answer "${w.text}" (indices ${seen.get(key)} and ${i})`);
    }
    seen.set(key, i);

    if (key === q.right.text.toLowerCase().trim()) {
      error(q.id, `Wrong answer "${w.text}" matches the correct answer`);
    }
  }
}

// ============================================================
// File validator
// ============================================================

function validateFile(filePath: string) {
  let content: string;
  try {
    content = readFileSync(filePath, "utf-8");
  } catch {
    error(filePath, `Cannot read file: ${filePath}`);
    return;
  }

  const parsed = parseTxtFile(content);
  const mcqCount = parsed.questions.filter((q) => q.type === "mcq").length;
  const inputCount = parsed.questions.filter((q) => q.type === "input").length;

  console.log(`\nFile: ${filePath}`);
  console.log(`  Rule   : ${parsed.ruleId} — ${parsed.ruleTitle}`);
  console.log(`  Author : ${parsed.generatedBy || "(missing)"}`);
  console.log(`  Found  : ${parsed.questions.length} questions (${mcqCount} MCQ, ${inputCount} INPUT)`);
  console.log(`  Declared: ${parsed.declaredMcq} MCQ + ${parsed.declaredInput} INPUT = ${parsed.declaredMcq + parsed.declaredInput}`);

  const ref = parsed.ruleId || filePath;

  // Parse errors
  for (const e of parsed.parseErrors) {
    error(ref, `Parse error — ${e}`);
  }

  // Header completeness
  if (!parsed.ruleId) error(ref, "Missing RULE header");
  if (!parsed.generatedBy) warn(ref, "Missing 'Generated by' field");
  if (parsed.declaredMcq === 0 && parsed.declaredInput === 0) {
    warn(ref, "Missing or unparseable Total header");
  }

  // Count matches
  if (mcqCount !== parsed.declaredMcq) {
    error(ref, `MCQ count mismatch: declared ${parsed.declaredMcq}, found ${mcqCount}`);
  }
  if (inputCount !== parsed.declaredInput) {
    error(ref, `INPUT count mismatch: declared ${parsed.declaredInput}, found ${inputCount}`);
  }

  // Duplicate IDs
  const seenIds = new Set<string>();
  for (const q of parsed.questions) {
    if (seenIds.has(q.id)) error(q.id, "Duplicate question ID");
    seenIds.add(q.id);
  }

  // Per-question validation
  for (const q of parsed.questions) {
    if (q.type === "mcq") validateMcq(q);
    else validateInput(q);
  }
}

// ============================================================
// Main
// ============================================================

function main() {
  const files = process.argv.slice(2);

  if (files.length === 0) {
    console.error("Usage: npx tsx scripts/validate-txt.ts <file.txt> [<file2.txt> ...]");
    process.exit(1);
  }

  for (const f of files) validateFile(f);

  console.log(`\n${"=".repeat(50)}`);
  console.log(`Errors: ${errorCount}, Warnings: ${warnCount}`);

  if (errorCount > 0) {
    console.log("VALIDATION FAILED");
    process.exit(1);
  } else {
    console.log("VALIDATION PASSED");
  }
}

main();
