/**
 * Merges multiple .txt question files into a single clean file.
 * Later files take priority for duplicate question IDs — use this to overlay
 * a -fixed.txt on top of a -passed.txt after running split-txt.
 *
 * The merged file gets a recalculated header and is ready for convert-txt.
 *
 * Usage:
 *   npx tsx scripts/merge-txt.ts --output questions/01-01.txt 01-01-passed.txt 01-01-fixed.txt
 */

import { readFileSync, writeFileSync, mkdirSync } from "fs";
import { dirname } from "path";
import {
  parseTxtFile,
  type ParsedQuestion,
  type ParsedInputQuestion,
} from "./lib/parse-txt.js";

// ============================================================
// Serializer — ParsedQuestion → txt block
// ============================================================

function serializeQuestion(q: ParsedQuestion): string {
  const lines: string[] = [];
  lines.push("BEGIN QUESTION");
  lines.push(`ID: ${q.id}`);
  lines.push(`TYPE: ${q.type.toUpperCase()}`);
  lines.push(`PROMPT: ${q.prompt}`);
  if (q.type === "input") {
    lines.push(`PHRASE: ${(q as ParsedInputQuestion).phrase}`);
  }
  lines.push(`RIGHT ANSWER: ${q.right.text}`);
  lines.push(`EXPLANATION: ${q.right.explanation}`);
  for (const w of q.wrongs) {
    lines.push(`WRONG ANSWER: ${w.text}`);
    lines.push(`EXPLANATION: ${w.explanation}`);
  }
  lines.push("END QUESTION");
  return lines.join("\n");
}

// ============================================================
// Main
// ============================================================

function main() {
  const args = process.argv.slice(2);

  const outputIdx = args.indexOf("--output");
  if (outputIdx === -1 || outputIdx + 1 >= args.length) {
    console.error(
      "Usage: npx tsx scripts/merge-txt.ts --output <outfile> <file1.txt> [<file2.txt> ...]",
    );
    process.exit(1);
  }

  const outputPath = args[outputIdx + 1]!;
  const inputFiles = args.filter((_, i) => i !== outputIdx && i !== outputIdx + 1);

  if (inputFiles.length === 0) {
    console.error("ERROR: No input files specified.");
    process.exit(1);
  }

  // Parse all input files. First file provides metadata; later files override
  // questions with the same ID (so a -fixed.txt overlays a -passed.txt cleanly).
  let ruleId = "";
  let ruleTitle = "";
  let generatedBy = "";

  // questionOrder preserves first-seen insertion order; questionMap stores latest version.
  const questionOrder: string[] = [];
  const questionMap = new Map<string, ParsedQuestion>();

  for (const filePath of inputFiles) {
    let content: string;
    try {
      content = readFileSync(filePath, "utf-8");
    } catch {
      console.error(`ERROR: Cannot read "${filePath}"`);
      process.exit(1);
    }

    const parsed = parseTxtFile(content);

    if (parsed.parseErrors.length > 0) {
      console.error(`Parse errors in ${filePath}:`);
      for (const e of parsed.parseErrors) console.error(`  ${e}`);
      process.exit(1);
    }

    if (!ruleId) {
      ruleId = parsed.ruleId;
      ruleTitle = parsed.ruleTitle;
      generatedBy = parsed.generatedBy;
    }

    for (const q of parsed.questions) {
      if (!questionMap.has(q.id)) {
        questionOrder.push(q.id); // track first-seen order
      }
      questionMap.set(q.id, q); // later files win on conflict
    }
  }

  const questions = questionOrder.map((id) => questionMap.get(id)!);
  const mcqCount = questions.filter((q) => q.type === "mcq").length;
  const inputCount = questions.filter((q) => q.type === "input").length;

  const header = [
    `RULE ${ruleId}: ${ruleTitle}`,
    `Generated by: ${generatedBy}`,
    `Total: ${mcqCount} MCQ + ${inputCount} input = ${mcqCount + inputCount} questions`,
  ].join("\n");

  const output = header + "\n\n" + questions.map(serializeQuestion).join("\n\n") + "\n";

  mkdirSync(dirname(outputPath), { recursive: true });
  writeFileSync(outputPath, output, "utf-8");

  console.log(
    `Merged ${questions.length} questions (${mcqCount} MCQ, ${inputCount} INPUT) → ${outputPath}`,
  );
  console.log(`  Sources: ${inputFiles.join(", ")}`);
}

main();
